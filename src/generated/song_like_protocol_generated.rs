/*
 * Copyright 2021 nzelot<leontsteiner@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_PAYLOAD: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_PAYLOAD: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_PAYLOAD: [MessagePayload; 3] = [
  MessagePayload::NONE,
  MessagePayload::Response,
  MessagePayload::Request,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessagePayload(pub u8);
#[allow(non_upper_case_globals)]
impl MessagePayload {
  pub const NONE: Self = Self(0);
  pub const Response: Self = Self(1);
  pub const Request: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Response,
    Self::Request,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Response => Some("Response"),
      Self::Request => Some("Request"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for MessagePayload {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MessagePayload {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MessagePayload {
    type Output = MessagePayload;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MessagePayload {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MessagePayload {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessagePayload {}
pub struct MessagePayloadUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RESPONSE_KIND: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RESPONSE_KIND: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESPONSE_KIND: [ResponseKind; 5] = [
  ResponseKind::NOT_FOUND,
  ResponseKind::FOUND_NOT_FAVED,
  ResponseKind::FOUND_FAVED,
  ResponseKind::FOUND_NOW_FAVED,
  ResponseKind::FOUND_NOW_NOT_FAVED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ResponseKind(pub u8);
#[allow(non_upper_case_globals)]
impl ResponseKind {
  pub const NOT_FOUND: Self = Self(0);
  pub const FOUND_NOT_FAVED: Self = Self(1);
  pub const FOUND_FAVED: Self = Self(2);
  pub const FOUND_NOW_FAVED: Self = Self(3);
  pub const FOUND_NOW_NOT_FAVED: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NOT_FOUND,
    Self::FOUND_NOT_FAVED,
    Self::FOUND_FAVED,
    Self::FOUND_NOW_FAVED,
    Self::FOUND_NOW_NOT_FAVED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NOT_FOUND => Some("NOT_FOUND"),
      Self::FOUND_NOT_FAVED => Some("FOUND_NOT_FAVED"),
      Self::FOUND_FAVED => Some("FOUND_FAVED"),
      Self::FOUND_NOW_FAVED => Some("FOUND_NOW_FAVED"),
      Self::FOUND_NOW_NOT_FAVED => Some("FOUND_NOW_NOT_FAVED"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for ResponseKind {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ResponseKind {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ResponseKind {
    type Output = ResponseKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ResponseKind {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ResponseKind {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ResponseKind {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SOURCE_KIND: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SOURCE_KIND: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOURCE_KIND: [SourceKind; 3] = [
  SourceKind::RADIO,
  SourceKind::BLUETOOTH,
  SourceKind::SNAPCAST,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SourceKind(pub u8);
#[allow(non_upper_case_globals)]
impl SourceKind {
  pub const RADIO: Self = Self(0);
  pub const BLUETOOTH: Self = Self(1);
  pub const SNAPCAST: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RADIO,
    Self::BLUETOOTH,
    Self::SNAPCAST,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RADIO => Some("RADIO"),
      Self::BLUETOOTH => Some("BLUETOOTH"),
      Self::SNAPCAST => Some("SNAPCAST"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for SourceKind {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SourceKind {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SourceKind {
    type Output = SourceKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SourceKind {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SourceKind {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SourceKind {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REQUEST_ACTION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REQUEST_ACTION: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REQUEST_ACTION: [RequestAction; 3] = [
  RequestAction::INFO,
  RequestAction::FAV,
  RequestAction::UNFAV,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RequestAction(pub u8);
#[allow(non_upper_case_globals)]
impl RequestAction {
  pub const INFO: Self = Self(0);
  pub const FAV: Self = Self(1);
  pub const UNFAV: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INFO,
    Self::FAV,
    Self::UNFAV,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::INFO => Some("INFO"),
      Self::FAV => Some("FAV"),
      Self::UNFAV => Some("UNFAV"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for RequestAction {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RequestAction {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RequestAction {
    type Output = RequestAction;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RequestAction {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RequestAction {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RequestAction {}
pub enum SongMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SongMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SongMessage<'a> {
    type Inner = SongMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SongMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SongMessage { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SongMessageArgs) -> flatbuffers::WIPOffset<SongMessage<'bldr>> {
      let mut builder = SongMessageBuilder::new(_fbb);
      builder.add_id(args.id);
      if let Some(x) = args.payload { builder.add_payload(x); }
      builder.add_payload_type(args.payload_type);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn id(&self) -> u64 {
    self._tab.get::<u64>(SongMessage::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn payload_type(&self) -> MessagePayload {
    self._tab.get::<MessagePayload>(SongMessage::VT_PAYLOAD_TYPE, Some(MessagePayload::NONE)).unwrap()
  }
  #[inline]
  pub fn payload(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SongMessage::VT_PAYLOAD, None).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_response(&self) -> Option<Response<'a>> {
    if self.payload_type() == MessagePayload::Response {
      let u = self.payload();
      Some(Response::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_request(&self) -> Option<Request<'a>> {
    if self.payload_type() == MessagePayload::Request {
      let u = self.payload();
      Some(Request::init_from_table(u))
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for SongMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>(&"id", Self::VT_ID, false)?
     .visit_union::<MessagePayload, _>(&"payload_type", Self::VT_PAYLOAD_TYPE, &"payload", Self::VT_PAYLOAD, true, |key, v, pos| {
        match key {
          MessagePayload::Response => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Response>>("MessagePayload::Response", pos),
          MessagePayload::Request => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Request>>("MessagePayload::Request", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct SongMessageArgs {
    pub id: u64,
    pub payload_type: MessagePayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SongMessageArgs {
    #[inline]
    fn default() -> Self {
        SongMessageArgs {
            id: 0,
            payload_type: MessagePayload::NONE,
            payload: None, // required field
        }
    }
}
pub struct SongMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SongMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(SongMessage::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: MessagePayload) {
    self.fbb_.push_slot::<MessagePayload>(SongMessage::VT_PAYLOAD_TYPE, payload_type, MessagePayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SongMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SongMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SongMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SongMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SongMessage::VT_PAYLOAD,"payload");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SongMessage<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SongMessage");
      ds.field("id", &self.id());
      ds.field("payload_type", &self.payload_type());
      match self.payload_type() {
        MessagePayload::Response => {
          if let Some(x) = self.payload_as_response() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::Request => {
          if let Some(x) = self.payload_as_request() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("payload", &x)
        },
      };
      ds.finish()
  }
}
pub enum ResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Response<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Response<'a> {
    type Inner = Response<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Response<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Response { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ResponseArgs) -> flatbuffers::WIPOffset<Response<'bldr>> {
      let mut builder = ResponseBuilder::new(_fbb);
      builder.add_kind(args.kind);
      builder.finish()
    }

    pub const VT_KIND: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn kind(&self) -> ResponseKind {
    self._tab.get::<ResponseKind>(Response::VT_KIND, Some(ResponseKind::NOT_FOUND)).unwrap()
  }
}

impl flatbuffers::Verifiable for Response<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ResponseKind>(&"kind", Self::VT_KIND, false)?
     .finish();
    Ok(())
  }
}
pub struct ResponseArgs {
    pub kind: ResponseKind,
}
impl<'a> Default for ResponseArgs {
    #[inline]
    fn default() -> Self {
        ResponseArgs {
            kind: ResponseKind::NOT_FOUND,
        }
    }
}
pub struct ResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_kind(&mut self, kind: ResponseKind) {
    self.fbb_.push_slot::<ResponseKind>(Response::VT_KIND, kind, ResponseKind::NOT_FOUND);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Response<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Response<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Response");
      ds.field("kind", &self.kind());
      ds.finish()
  }
}
pub enum SongInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SongInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SongInfo<'a> {
    type Inner = SongInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SongInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SongInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SongInfoArgs<'args>) -> flatbuffers::WIPOffset<SongInfo<'bldr>> {
      let mut builder = SongInfoBuilder::new(_fbb);
      if let Some(x) = args.song_album { builder.add_song_album(x); }
      if let Some(x) = args.song_artist { builder.add_song_artist(x); }
      if let Some(x) = args.song_title { builder.add_song_title(x); }
      if let Some(x) = args.raw_meta { builder.add_raw_meta(x); }
      builder.finish()
    }

    pub const VT_RAW_META: flatbuffers::VOffsetT = 4;
    pub const VT_SONG_TITLE: flatbuffers::VOffsetT = 6;
    pub const VT_SONG_ARTIST: flatbuffers::VOffsetT = 8;
    pub const VT_SONG_ALBUM: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn raw_meta(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SongInfo::VT_RAW_META, None).unwrap()
  }
  #[inline]
  pub fn song_title(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SongInfo::VT_SONG_TITLE, None)
  }
  #[inline]
  pub fn song_artist(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SongInfo::VT_SONG_ARTIST, None)
  }
  #[inline]
  pub fn song_album(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SongInfo::VT_SONG_ALBUM, None)
  }
}

impl flatbuffers::Verifiable for SongInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"raw_meta", Self::VT_RAW_META, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"song_title", Self::VT_SONG_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"song_artist", Self::VT_SONG_ARTIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"song_album", Self::VT_SONG_ALBUM, false)?
     .finish();
    Ok(())
  }
}
pub struct SongInfoArgs<'a> {
    pub raw_meta: Option<flatbuffers::WIPOffset<&'a str>>,
    pub song_title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub song_artist: Option<flatbuffers::WIPOffset<&'a str>>,
    pub song_album: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SongInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        SongInfoArgs {
            raw_meta: None, // required field
            song_title: None,
            song_artist: None,
            song_album: None,
        }
    }
}
pub struct SongInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SongInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_raw_meta(&mut self, raw_meta: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SongInfo::VT_RAW_META, raw_meta);
  }
  #[inline]
  pub fn add_song_title(&mut self, song_title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SongInfo::VT_SONG_TITLE, song_title);
  }
  #[inline]
  pub fn add_song_artist(&mut self, song_artist: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SongInfo::VT_SONG_ARTIST, song_artist);
  }
  #[inline]
  pub fn add_song_album(&mut self, song_album: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SongInfo::VT_SONG_ALBUM, song_album);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SongInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SongInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SongInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SongInfo::VT_RAW_META,"raw_meta");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SongInfo<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SongInfo");
      ds.field("raw_meta", &self.raw_meta());
      ds.field("song_title", &self.song_title());
      ds.field("song_artist", &self.song_artist());
      ds.field("song_album", &self.song_album());
      ds.finish()
  }
}
pub enum SongSourceInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SongSourceInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SongSourceInfo<'a> {
    type Inner = SongSourceInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SongSourceInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SongSourceInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SongSourceInfoArgs<'args>) -> flatbuffers::WIPOffset<SongSourceInfo<'bldr>> {
      let mut builder = SongSourceInfoBuilder::new(_fbb);
      if let Some(x) = args.source_name { builder.add_source_name(x); }
      builder.add_source_kind(args.source_kind);
      builder.finish()
    }

    pub const VT_SOURCE_KIND: flatbuffers::VOffsetT = 4;
    pub const VT_SOURCE_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn source_kind(&self) -> SourceKind {
    self._tab.get::<SourceKind>(SongSourceInfo::VT_SOURCE_KIND, Some(SourceKind::RADIO)).unwrap()
  }
  #[inline]
  pub fn source_name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SongSourceInfo::VT_SOURCE_NAME, None).unwrap()
  }
}

impl flatbuffers::Verifiable for SongSourceInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<SourceKind>(&"source_kind", Self::VT_SOURCE_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"source_name", Self::VT_SOURCE_NAME, true)?
     .finish();
    Ok(())
  }
}
pub struct SongSourceInfoArgs<'a> {
    pub source_kind: SourceKind,
    pub source_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SongSourceInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        SongSourceInfoArgs {
            source_kind: SourceKind::RADIO,
            source_name: None, // required field
        }
    }
}
pub struct SongSourceInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SongSourceInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_source_kind(&mut self, source_kind: SourceKind) {
    self.fbb_.push_slot::<SourceKind>(SongSourceInfo::VT_SOURCE_KIND, source_kind, SourceKind::RADIO);
  }
  #[inline]
  pub fn add_source_name(&mut self, source_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SongSourceInfo::VT_SOURCE_NAME, source_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SongSourceInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SongSourceInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SongSourceInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SongSourceInfo::VT_SOURCE_NAME,"source_name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SongSourceInfo<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SongSourceInfo");
      ds.field("source_kind", &self.source_kind());
      ds.field("source_name", &self.source_name());
      ds.finish()
  }
}
pub enum RequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Request<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Request<'a> {
    type Inner = Request<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Request<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Request { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RequestArgs<'args>) -> flatbuffers::WIPOffset<Request<'bldr>> {
      let mut builder = RequestBuilder::new(_fbb);
      if let Some(x) = args.song_info { builder.add_song_info(x); }
      if let Some(x) = args.song_source_info { builder.add_song_source_info(x); }
      if let Some(x) = args.requesting_party { builder.add_requesting_party(x); }
      builder.add_action_kind(args.action_kind);
      builder.finish()
    }

    pub const VT_REQUESTING_PARTY: flatbuffers::VOffsetT = 4;
    pub const VT_ACTION_KIND: flatbuffers::VOffsetT = 6;
    pub const VT_SONG_SOURCE_INFO: flatbuffers::VOffsetT = 8;
    pub const VT_SONG_INFO: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn requesting_party(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Request::VT_REQUESTING_PARTY, None).unwrap()
  }
  #[inline]
  pub fn action_kind(&self) -> RequestAction {
    self._tab.get::<RequestAction>(Request::VT_ACTION_KIND, Some(RequestAction::INFO)).unwrap()
  }
  #[inline]
  pub fn song_source_info(&self) -> SongSourceInfo<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SongSourceInfo>>(Request::VT_SONG_SOURCE_INFO, None).unwrap()
  }
  #[inline]
  pub fn song_info(&self) -> SongInfo<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SongInfo>>(Request::VT_SONG_INFO, None).unwrap()
  }
}

impl flatbuffers::Verifiable for Request<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"requesting_party", Self::VT_REQUESTING_PARTY, true)?
     .visit_field::<RequestAction>(&"action_kind", Self::VT_ACTION_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SongSourceInfo>>(&"song_source_info", Self::VT_SONG_SOURCE_INFO, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<SongInfo>>(&"song_info", Self::VT_SONG_INFO, true)?
     .finish();
    Ok(())
  }
}
pub struct RequestArgs<'a> {
    pub requesting_party: Option<flatbuffers::WIPOffset<&'a str>>,
    pub action_kind: RequestAction,
    pub song_source_info: Option<flatbuffers::WIPOffset<SongSourceInfo<'a>>>,
    pub song_info: Option<flatbuffers::WIPOffset<SongInfo<'a>>>,
}
impl<'a> Default for RequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        RequestArgs {
            requesting_party: None, // required field
            action_kind: RequestAction::INFO,
            song_source_info: None, // required field
            song_info: None, // required field
        }
    }
}
pub struct RequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_requesting_party(&mut self, requesting_party: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_REQUESTING_PARTY, requesting_party);
  }
  #[inline]
  pub fn add_action_kind(&mut self, action_kind: RequestAction) {
    self.fbb_.push_slot::<RequestAction>(Request::VT_ACTION_KIND, action_kind, RequestAction::INFO);
  }
  #[inline]
  pub fn add_song_source_info(&mut self, song_source_info: flatbuffers::WIPOffset<SongSourceInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SongSourceInfo>>(Request::VT_SONG_SOURCE_INFO, song_source_info);
  }
  #[inline]
  pub fn add_song_info(&mut self, song_info: flatbuffers::WIPOffset<SongInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SongInfo>>(Request::VT_SONG_INFO, song_info);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Request<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Request::VT_REQUESTING_PARTY,"requesting_party");
    self.fbb_.required(o, Request::VT_SONG_SOURCE_INFO,"song_source_info");
    self.fbb_.required(o, Request::VT_SONG_INFO,"song_info");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Request<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Request");
      ds.field("requesting_party", &self.requesting_party());
      ds.field("action_kind", &self.action_kind());
      ds.field("song_source_info", &self.song_source_info());
      ds.field("song_info", &self.song_info());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_song_message<'a>(buf: &'a [u8]) -> SongMessage<'a> {
  unsafe { flatbuffers::root_unchecked::<SongMessage<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_song_message<'a>(buf: &'a [u8]) -> SongMessage<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<SongMessage<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `SongMessage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_song_message_unchecked`.
pub fn root_as_song_message(buf: &[u8]) -> Result<SongMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SongMessage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SongMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_song_message_unchecked`.
pub fn size_prefixed_root_as_song_message(buf: &[u8]) -> Result<SongMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SongMessage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SongMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_song_message_unchecked`.
pub fn root_as_song_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SongMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SongMessage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SongMessage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_song_message_unchecked`.
pub fn size_prefixed_root_as_song_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SongMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SongMessage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SongMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SongMessage`.
pub unsafe fn root_as_song_message_unchecked(buf: &[u8]) -> SongMessage {
  flatbuffers::root_unchecked::<SongMessage>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SongMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SongMessage`.
pub unsafe fn size_prefixed_root_as_song_message_unchecked(buf: &[u8]) -> SongMessage {
  flatbuffers::size_prefixed_root_unchecked::<SongMessage>(buf)
}
#[inline]
pub fn finish_song_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<SongMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_song_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<SongMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
