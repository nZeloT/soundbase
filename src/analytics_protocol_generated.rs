// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum AnalyticsMessageType {
  NONE = 0,
  PageChange = 1,
  PlaybackChange = 2,
  PlaybackSongChange = 3,

}

const ENUM_MIN_ANALYTICS_MESSAGE_TYPE: u8 = 0;
const ENUM_MAX_ANALYTICS_MESSAGE_TYPE: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for AnalyticsMessageType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for AnalyticsMessageType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const AnalyticsMessageType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const AnalyticsMessageType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for AnalyticsMessageType {
    type Output = AnalyticsMessageType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<AnalyticsMessageType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_ANALYTICS_MESSAGE_TYPE:[AnalyticsMessageType; 4] = [
  AnalyticsMessageType::NONE,
  AnalyticsMessageType::PageChange,
  AnalyticsMessageType::PlaybackChange,
  AnalyticsMessageType::PlaybackSongChange
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_ANALYTICS_MESSAGE_TYPE:[&'static str; 4] = [
    "NONE",
    "PageChange",
    "PlaybackChange",
    "PlaybackSongChange"
];

pub fn enum_name_analytics_message_type(e: AnalyticsMessageType) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_ANALYTICS_MESSAGE_TYPE[index as usize]
}

pub struct AnalyticsMessageTypeUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Page {
  INACTIVE = 0,
  LOADING = 1,
  MENU_SELECTION = 2,
  OPTIONS = 3,
  RADIO_PLAYING = 4,
  RADIO_SELECTION = 5,
  BT_PLAYING = 6,
  SNAPCAST_PLAYING = 7,

}

const ENUM_MIN_PAGE: i8 = 0;
const ENUM_MAX_PAGE: i8 = 7;

impl<'a> flatbuffers::Follow<'a> for Page {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Page {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const Page;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const Page;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Page {
    type Output = Page;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Page>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_PAGE:[Page; 8] = [
  Page::INACTIVE,
  Page::LOADING,
  Page::MENU_SELECTION,
  Page::OPTIONS,
  Page::RADIO_PLAYING,
  Page::RADIO_SELECTION,
  Page::BT_PLAYING,
  Page::SNAPCAST_PLAYING
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_PAGE:[&'static str; 8] = [
    "INACTIVE",
    "LOADING",
    "MENU_SELECTION",
    "OPTIONS",
    "RADIO_PLAYING",
    "RADIO_SELECTION",
    "BT_PLAYING",
    "SNAPCAST_PLAYING"
];

pub fn enum_name_page(e: Page) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_PAGE[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum PlaybackSource {
  RADIO = 0,
  BLUETOOTH = 1,
  SNAPCAST = 2,

}

const ENUM_MIN_PLAYBACK_SOURCE: u8 = 0;
const ENUM_MAX_PLAYBACK_SOURCE: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for PlaybackSource {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for PlaybackSource {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const PlaybackSource;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const PlaybackSource;
    unsafe { *p }
  }
}

impl flatbuffers::Push for PlaybackSource {
    type Output = PlaybackSource;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<PlaybackSource>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_PLAYBACK_SOURCE:[PlaybackSource; 3] = [
  PlaybackSource::RADIO,
  PlaybackSource::BLUETOOTH,
  PlaybackSource::SNAPCAST
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_PLAYBACK_SOURCE:[&'static str; 3] = [
    "RADIO",
    "BLUETOOTH",
    "SNAPCAST"
];

pub fn enum_name_playback_source(e: PlaybackSource) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_PLAYBACK_SOURCE[index as usize]
}

pub enum AnalyticsMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AnalyticsMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnalyticsMessage<'a> {
    type Inner = AnalyticsMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AnalyticsMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AnalyticsMessage {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AnalyticsMessageArgs<'args>) -> flatbuffers::WIPOffset<AnalyticsMessage<'bldr>> {
      let mut builder = AnalyticsMessageBuilder::new(_fbb);
      builder.add_timestamp(args.timestamp);
      if let Some(x) = args.payload { builder.add_payload(x); }
      if let Some(x) = args.origin { builder.add_origin(x); }
      builder.add_payload_type(args.payload_type);
      builder.finish()
    }

    pub const VT_ORIGIN: flatbuffers::VOffsetT = 4;
    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;
    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AnalyticsMessage::VT_ORIGIN, None)
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    self._tab.get::<u64>(AnalyticsMessage::VT_TIMESTAMP, Some(0)).unwrap()
  }
  #[inline]
  pub fn payload_type(&self) -> AnalyticsMessageType {
    self._tab.get::<AnalyticsMessageType>(AnalyticsMessage::VT_PAYLOAD_TYPE, Some(AnalyticsMessageType::NONE)).unwrap()
  }
  #[inline]
  pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(AnalyticsMessage::VT_PAYLOAD, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_page_change(&self) -> Option<PageChange<'a>> {
    if self.payload_type() == AnalyticsMessageType::PageChange {
      self.payload().map(|u| PageChange::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_playback_change(&self) -> Option<PlaybackChange<'a>> {
    if self.payload_type() == AnalyticsMessageType::PlaybackChange {
      self.payload().map(|u| PlaybackChange::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_playback_song_change(&self) -> Option<PlaybackSongChange<'a>> {
    if self.payload_type() == AnalyticsMessageType::PlaybackSongChange {
      self.payload().map(|u| PlaybackSongChange::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct AnalyticsMessageArgs<'a> {
    pub origin: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub timestamp: u64,
    pub payload_type: AnalyticsMessageType,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for AnalyticsMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        AnalyticsMessageArgs {
            origin: None,
            timestamp: 0,
            payload_type: AnalyticsMessageType::NONE,
            payload: None,
        }
    }
}
pub struct AnalyticsMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AnalyticsMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnalyticsMessage::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(AnalyticsMessage::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: AnalyticsMessageType) {
    self.fbb_.push_slot::<AnalyticsMessageType>(AnalyticsMessage::VT_PAYLOAD_TYPE, payload_type, AnalyticsMessageType::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AnalyticsMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AnalyticsMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AnalyticsMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AnalyticsMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PageChangeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PageChange<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PageChange<'a> {
    type Inner = PageChange<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PageChange<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PageChange {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PageChangeArgs) -> flatbuffers::WIPOffset<PageChange<'bldr>> {
      let mut builder = PageChangeBuilder::new(_fbb);
      builder.add_destination(args.destination);
      builder.add_origin(args.origin);
      builder.finish()
    }

    pub const VT_ORIGIN: flatbuffers::VOffsetT = 4;
    pub const VT_DESTINATION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn origin(&self) -> Page {
    self._tab.get::<Page>(PageChange::VT_ORIGIN, Some(Page::INACTIVE)).unwrap()
  }
  #[inline]
  pub fn destination(&self) -> Page {
    self._tab.get::<Page>(PageChange::VT_DESTINATION, Some(Page::INACTIVE)).unwrap()
  }
}

pub struct PageChangeArgs {
    pub origin: Page,
    pub destination: Page,
}
impl<'a> Default for PageChangeArgs {
    #[inline]
    fn default() -> Self {
        PageChangeArgs {
            origin: Page::INACTIVE,
            destination: Page::INACTIVE,
        }
    }
}
pub struct PageChangeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PageChangeBuilder<'a, 'b> {
  #[inline]
  pub fn add_origin(&mut self, origin: Page) {
    self.fbb_.push_slot::<Page>(PageChange::VT_ORIGIN, origin, Page::INACTIVE);
  }
  #[inline]
  pub fn add_destination(&mut self, destination: Page) {
    self.fbb_.push_slot::<Page>(PageChange::VT_DESTINATION, destination, Page::INACTIVE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PageChangeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PageChangeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PageChange<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PlaybackChangeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PlaybackChange<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlaybackChange<'a> {
    type Inner = PlaybackChange<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PlaybackChange<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PlaybackChange {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PlaybackChangeArgs<'args>) -> flatbuffers::WIPOffset<PlaybackChange<'bldr>> {
      let mut builder = PlaybackChangeBuilder::new(_fbb);
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_source(args.source);
      builder.add_started(args.started);
      builder.finish()
    }

    pub const VT_STARTED: flatbuffers::VOffsetT = 4;
    pub const VT_SOURCE: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn started(&self) -> bool {
    self._tab.get::<bool>(PlaybackChange::VT_STARTED, Some(false)).unwrap()
  }
  #[inline]
  pub fn source(&self) -> PlaybackSource {
    self._tab.get::<PlaybackSource>(PlaybackChange::VT_SOURCE, Some(PlaybackSource::RADIO)).unwrap()
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PlaybackChange::VT_NAME, None)
  }
}

pub struct PlaybackChangeArgs<'a> {
    pub started: bool,
    pub source: PlaybackSource,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for PlaybackChangeArgs<'a> {
    #[inline]
    fn default() -> Self {
        PlaybackChangeArgs {
            started: false,
            source: PlaybackSource::RADIO,
            name: None,
        }
    }
}
pub struct PlaybackChangeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlaybackChangeBuilder<'a, 'b> {
  #[inline]
  pub fn add_started(&mut self, started: bool) {
    self.fbb_.push_slot::<bool>(PlaybackChange::VT_STARTED, started, false);
  }
  #[inline]
  pub fn add_source(&mut self, source: PlaybackSource) {
    self.fbb_.push_slot::<PlaybackSource>(PlaybackChange::VT_SOURCE, source, PlaybackSource::RADIO);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlaybackChange::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlaybackChangeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlaybackChangeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlaybackChange<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PlaybackSongChangeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PlaybackSongChange<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlaybackSongChange<'a> {
    type Inner = PlaybackSongChange<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PlaybackSongChange<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PlaybackSongChange {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PlaybackSongChangeArgs<'args>) -> flatbuffers::WIPOffset<PlaybackSongChange<'bldr>> {
      let mut builder = PlaybackSongChangeBuilder::new(_fbb);
      if let Some(x) = args.album { builder.add_album(x); }
      if let Some(x) = args.artist { builder.add_artist(x); }
      if let Some(x) = args.title { builder.add_title(x); }
      if let Some(x) = args.raw_meta { builder.add_raw_meta(x); }
      builder.finish()
    }

    pub const VT_RAW_META: flatbuffers::VOffsetT = 4;
    pub const VT_TITLE: flatbuffers::VOffsetT = 6;
    pub const VT_ARTIST: flatbuffers::VOffsetT = 8;
    pub const VT_ALBUM: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn raw_meta(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PlaybackSongChange::VT_RAW_META, None)
  }
  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PlaybackSongChange::VT_TITLE, None)
  }
  #[inline]
  pub fn artist(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PlaybackSongChange::VT_ARTIST, None)
  }
  #[inline]
  pub fn album(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PlaybackSongChange::VT_ALBUM, None)
  }
}

pub struct PlaybackSongChangeArgs<'a> {
    pub raw_meta: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub artist: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub album: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for PlaybackSongChangeArgs<'a> {
    #[inline]
    fn default() -> Self {
        PlaybackSongChangeArgs {
            raw_meta: None,
            title: None,
            artist: None,
            album: None,
        }
    }
}
pub struct PlaybackSongChangeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlaybackSongChangeBuilder<'a, 'b> {
  #[inline]
  pub fn add_raw_meta(&mut self, raw_meta: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlaybackSongChange::VT_RAW_META, raw_meta);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlaybackSongChange::VT_TITLE, title);
  }
  #[inline]
  pub fn add_artist(&mut self, artist: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlaybackSongChange::VT_ARTIST, artist);
  }
  #[inline]
  pub fn add_album(&mut self, album: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlaybackSongChange::VT_ALBUM, album);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlaybackSongChangeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlaybackSongChangeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlaybackSongChange<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_analytics_message<'a>(buf: &'a [u8]) -> AnalyticsMessage<'a> {
  flatbuffers::get_root::<AnalyticsMessage<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_analytics_message<'a>(buf: &'a [u8]) -> AnalyticsMessage<'a> {
  flatbuffers::get_size_prefixed_root::<AnalyticsMessage<'a>>(buf)
}

#[inline]
pub fn finish_analytics_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<AnalyticsMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_analytics_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<AnalyticsMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
